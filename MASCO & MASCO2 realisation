{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import msprime\n",
    "import numpy as np\n",
    "from tree import Tree\n",
    "import random\n",
    "import argparse\n",
    "import copy\n",
    "from struct import pack, unpack\n",
    "from sys import getsizeof\n",
    "from scipy.integrate import RK45, solve_ivp\n",
    "import matplotlib.pyplot as plt\n",
    "from IPython.display import SVG\n",
    "import copy\n",
    "import sys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy import special   # для биномиальных коэффициентов\n",
    "import struct\n",
    "\n",
    "\n",
    "class Tree:\n",
    "\n",
    "    def __init__(self, migration_rates: np.array, number_of_samples: np.array, number_of_populations: int, coalescence_rates: np.array, coalescence_time: float, Q: float, N: int):\n",
    "        # Извлечение данных из файла и создание объекта\n",
    "        # Данные в файле должны быть в таком порядке N, k, n, t, m, q, Q\n",
    "        # для отладки\n",
    "        self.__N = int(N)      # эталонный размер популяции\n",
    "        self.__number_of_populations = int(number_of_populations)  # количество популяций (m)\n",
    "        self.__number_of_samples = np.array(number_of_samples)\n",
    "        self.__samples_amount = int(np.sum(self.__number_of_samples))  #всего образцов дано (n)\n",
    "        self.__T = float(coalescence_time)      # время слияния всех популяций\n",
    "        self.__migration_probability = np.array(migration_rates)\n",
    "        self.__coalescence_probability = np.array(coalescence_rates)\n",
    "        self.__Q = float(Q)\n",
    "        self.__cur_samples_amount = self.__samples_amount\n",
    "        \n",
    "    def show(self):\n",
    "        print(self.__number_of_populations, self.__T, '\\n')\n",
    "        print(self.__number_of_samples, self.__samples_amount, '\\n')\n",
    "        print(self.__migration_probability, '\\n\\n', self.__coalescence_probability, '\\n')\n",
    "        #s = self.get_initial_states\n",
    "        #print(s)\n",
    "    @property\n",
    "    def original_size(self):\n",
    "        return self.__N\n",
    "\n",
    "    @property\n",
    "    def number_of_populations(self):\n",
    "        return self.__number_of_populations\n",
    "\n",
    "    @property\n",
    "    def number_of_samples(self):\n",
    "        return self.__number_of_samples\n",
    "\n",
    "    @property\n",
    "    def samples_amount(self):\n",
    "        return self.__samples_amount\n",
    "\n",
    "    @property\n",
    "    def T(self):\n",
    "        return self.__T\n",
    "\n",
    "    @property\n",
    "    def migration_probability(self):\n",
    "        return self.__migration_probability\n",
    "\n",
    "    @property\n",
    "    def coalescence_probability(self):\n",
    "        return self.__coalescence_probability\n",
    "\n",
    "    @property\n",
    "    def Q(self):\n",
    "        return self.__Q\n",
    "    \n",
    "    @property\n",
    "    def tree_newick(self):\n",
    "        return self.__tree_newick\n",
    "\n",
    "    @property\n",
    "    def cur_samples_amount(self):\n",
    "        return self.__cur_samples_amount\n",
    "\n",
    "    @cur_samples_amount.setter\n",
    "    def cur_samples_amount(self, cur_samples_amount):\n",
    "        if cur_samples_amount >= 1:\n",
    "            self.__cur_samples_amount = cur_samples_amount\n",
    "        else:\n",
    "            raise ValueError(\"the minimum number of samples has been reached\")\n",
    "\n",
    "    def get_initial_states(self):\n",
    "        \"\"\"\n",
    "        return result 1-D array of initial states\n",
    "        \"\"\"\n",
    "        result = []\n",
    "        current_samples_sum = 0\n",
    "        # по каждой популяции\n",
    "        for i in range(self.__number_of_populations):\n",
    "            # по каждому образцу\n",
    "            for j in range(self.__samples_amount):\n",
    "                # если образец в начальный момент принадлежит этой популяции\n",
    "                if(current_samples_sum <= j < current_samples_sum + self.__number_of_samples[i]):\n",
    "                    result.append(1)\n",
    "                else:\n",
    "                    result.append(0)\n",
    "            current_samples_sum += self.__number_of_samples[i]\n",
    "        return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def system_of_DE_for_lines(data: Tree, p: np.ndarray) -> np.ndarray:\n",
    "    \"\"\"\n",
    "    :param data: \n",
    "    :param p: p means P(L_i = l_i | T)\n",
    "    :return: (result) derivative of probability function for each line in any population,\n",
    "             1-D array with length = m * n\n",
    "    \"\"\"\n",
    "    result = []\n",
    "    value_of_cur_fun = 0\n",
    "    # по каждой популяции\n",
    "    for pop in range(data.number_of_populations):\n",
    "        # по всем образцам\n",
    "        for i in range(data.cur_samples_amount):\n",
    "            # *** обращение к нужному p через индекс ( pop * data.cur_samples_amount + i )\n",
    "            ################################################\n",
    "            # первое(1-я часть семмы) слагаемое\n",
    "            for a in range(data.number_of_populations):\n",
    "                value_of_cur_fun += data.migration_probability[a][pop] * p[a * data.cur_samples_amount + i]\n",
    "            ################################################\n",
    "            # первое(2-я часть суммы) слагаемое\n",
    "            for a in range(data.number_of_populations):\n",
    "                value_of_cur_fun -= data.migration_probability[pop][a] * p[pop * data.cur_samples_amount + i]\n",
    "            ################################################\n",
    "            # второе слагаемое\n",
    "            sum_of_mult = 0\n",
    "            for a in range(data.number_of_populations):\n",
    "                for j in range(data.cur_samples_amount):\n",
    "                    if j != i:\n",
    "                        for k in range(data.cur_samples_amount):\n",
    "                            if (k != i) and (k != j):\n",
    "                                t_sum1 = 0\n",
    "                                for l in range(data.number_of_populations):\n",
    "                                    t_sum1 += p[l * data.cur_samples_amount + k]\n",
    "                                t_sum2 = 0\n",
    "                                for l in range(data.number_of_populations):\n",
    "                                    t_sum2 += p[l * data.cur_samples_amount + j]\n",
    "                                sum_of_mult += (p[pop * data.cur_samples_amount + k]/t_sum1) * (p[pop * data.cur_samples_amount + j]/t_sum2)\n",
    "                    \n",
    "                \n",
    "            value_of_cur_fun -= sum_of_mult * 0.5 * data.coalescence_probability[a] * p[pop * data.cur_samples_amount + i] \n",
    "            ################################################\n",
    "            # третье слагаемое\n",
    "            tmp_sum = 0\n",
    "            for k in range(data.cur_samples_amount):\n",
    "                if k != i:\n",
    "                    t_sum = 0\n",
    "                    for l in range(data.number_of_populations):\n",
    "                        t_sum += p[l * data.cur_samples_amount + k]\n",
    "                    tmp_sum += p[pop * data.cur_samples_amount + k]/t_sum\n",
    "            value_of_cur_fun -= p[pop * data.cur_samples_amount + i] * data.coalescence_probability[pop] * tmp_sum\n",
    "            ################################################\n",
    "            result.append(value_of_cur_fun)\n",
    "            value_of_cur_fun = 0\n",
    "\n",
    "    return result\n",
    "\n",
    "\n",
    "\n",
    "def create_initial0(data: Tree,\n",
    "                   period: int,\n",
    "                   previous_states: np.ndarray = None,\n",
    "                   lineage: np.ndarray = None) -> np.ndarray:\n",
    "    \"\"\"\n",
    "    :param data:\n",
    "    :param period:\n",
    "    :param previous_states: probabilities before coalescence\n",
    "    :param lineage: contains two samples that participated in coalescence\n",
    "    :return: result: vector of initial states for current \"period\"\n",
    "    \"\"\"\n",
    "    # *** обращение к нужному p через индекс ( pop * data.cur_samples_amount + i )\n",
    "    if period == 0:\n",
    "        return data.get_initial_states()\n",
    "    else:\n",
    "        lineage = np.sort(lineage)\n",
    "        result = []\n",
    "        # cur_samples_sum = 0  ??нужно??\n",
    "\n",
    "        # посчитаю все условные вероятности для lineage[0] и всех 'pop'\n",
    "        conditional_prob = []\n",
    "        t_sum0 = 0\n",
    "        for l in range(data.number_of_populations):\n",
    "            t_sum0 += previous_states[l * (data.cur_samples_amount + 1) + lineage[0]]\n",
    "        t_sum1 = 0\n",
    "        for l in range(data.number_of_populations):\n",
    "            t_sum1 += previous_states[l * (data.cur_samples_amount + 1) + lineage[1]]\n",
    "        #print(t_sum0, t_sum1)\n",
    "        for pop in range(data.number_of_populations):\n",
    "            conditional_prob.append((previous_states[pop * (data.cur_samples_amount + 1) + lineage[0]]) *\n",
    "                                    (previous_states[pop * (data.cur_samples_amount + 1) + lineage[1]] / t_sum1) *\n",
    "                                    data.coalescence_probability[pop])\n",
    "        sum_conditional_prob = np.sum(conditional_prob)  # ??? нужно ли переводить в массив ???\n",
    "        # по каждой популяции\n",
    "        for pop in range(data.number_of_populations):\n",
    "            # по каждому образцу\n",
    "            for i in range(data.cur_samples_amount + 1):\n",
    "                # если образец участвовал в коалесценции и у него меньшее 'id', то есть он остался\n",
    "                if i == lineage[0]:\n",
    "                    # !!!!!!!!!!!!!! можно использовать уже посчитанные выше\n",
    "                    result.append((previous_states[pop * (data.cur_samples_amount + 1) + lineage[0]]) *\n",
    "                                    (previous_states[pop * (data.cur_samples_amount + 1) + lineage[1]] / t_sum1)*\n",
    "                                    data.coalescence_probability[pop])\n",
    "                # если образец участвовал в коалесценции и у него большее 'id', то есть он не остался\n",
    "                elif i == lineage[1]:  # добавила для лучшего понимания кода, но вообще этот if можно убрать\n",
    "                    continue\n",
    "                # если образец не участвовал в коалесценции\n",
    "                elif i != lineage[0] and i != lineage[1]:\n",
    "                    t_sum2 = 0\n",
    "                    for j in range(data.number_of_populations):\n",
    "                        t_sum2 += previous_states[j * (data.cur_samples_amount + 1) + i]\n",
    "                    result.append((previous_states[pop * (data.cur_samples_amount + 1) + i] / t_sum2) * sum_conditional_prob)\n",
    "\n",
    "            # cur_samples_sum += tree.number_of_samples[pop]  ??нужно??\n",
    "        return result\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "def system_of_DE_for_lines_2(data: Tree, p2: np.ndarray) -> np.ndarray:\n",
    "    \"\"\"\n",
    "    :param data: \n",
    "    :param p: p means P(L_i = l_i , L_j = l_j, T)  0.5 * n * (n-1) * m^2 length matrix \n",
    "    :return: (result) derivative of probability function for each line in any population,\n",
    "             1-D array with length = m * n\n",
    "    \"\"\"\n",
    "    result = [[] for i in range(data.number_of_populations ** 2)]\n",
    "    value_of_cur_fun = 0\n",
    "    # по каждой популяции\n",
    "    n = data.cur_samples_amount\n",
    "    #print(n)\n",
    "    p2 = np.reshape(p2, (data.number_of_populations ** 2, -1))\n",
    "    #print(p2)\n",
    "    for pop1 in range(data.number_of_populations):\n",
    "        for pop2 in range(data.number_of_populations):\n",
    "            # по всем образцам\n",
    "            for i in range(data.cur_samples_amount):\n",
    "                for j in range(data.cur_samples_amount):\n",
    "                    if i < j:\n",
    "                # *** обращение к нужному p через индекс ( pop * data.cur_samples_amount + i )\n",
    "                ################################################\n",
    "                # первое(1-я часть семмы) слагаемое\n",
    "                        for a in range(data.number_of_populations):    \n",
    "                            value_of_cur_fun += data.migration_probability[a][pop1] * p2[a * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] \n",
    "\n",
    "                            value_of_cur_fun += data.migration_probability[a][pop2] * p2[pop1 * data.number_of_populations + a, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)]\n",
    "                            value_of_cur_fun -= (data.migration_probability[pop1][a] + data.migration_probability[pop2][a]) * p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)]\n",
    "                    ################################################\n",
    "                    # первое(2-я часть суммы) слагаемое\n",
    "                    ################################################\n",
    "                    # второе слагаемое\n",
    "                        for a in range(data.number_of_populations):\n",
    "                            sum_of_mult = 0\n",
    "                            for s in range(data.cur_samples_amount):\n",
    "                                if (s != i) and (s != j):\n",
    "                                    for k in range(data.cur_samples_amount):\n",
    "                                        if (k != i) and (k != j) and (k != s) and (s < k):\n",
    "                                            t_sum = 0\n",
    "                                            for l in range(data.number_of_populations):\n",
    "                                                for q in range(data.number_of_populations):\n",
    "                                                    t_sum += p2[l * data.number_of_populations + q, int(n*(n-1)/2 - (n-s-1)*(n-s)/2 + k - s - 1)]\n",
    "\n",
    "                                            sum_of_mult += p2[a * data.number_of_populations + a, int(n*(n-1)/2 - (n-s-1)*(n-s)/2 + k - s - 1)]/t_sum\n",
    "\n",
    "                            \n",
    "                            value_of_cur_fun -= sum_of_mult * data.coalescence_probability[a] * p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)]\n",
    "                            #print(value_of_cur_fun, 0, i, j)\n",
    "                        ############################################\n",
    "                        # третье слагаемое\n",
    "                        for k in range(data.cur_samples_amount):\n",
    "                            if (k < i):\n",
    "                                t_sum = 0\n",
    "                                t_sum1 = 0\n",
    "                                t_sum2 = 0\n",
    "                                for l in range(data.number_of_populations):\n",
    "                                    for q in range(data.number_of_populations):\n",
    "                                        #print(k, i, j)\n",
    "                                        t_sum += p2[l * data.number_of_populations + q, int(n*(n-1)/2 - (n-k-1)*(n-k)/2 + i - k - 1)]\n",
    "                                t_sum1 += p2[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-k-1)*(n-k)/2 + i - k - 1)]\n",
    "                                t_sum2 += p2[pop2 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-k-1)*(n-k)/2 + j - k - 1)]\n",
    "                                value_of_cur_fun -= p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * ((t_sum1 * data.coalescence_probability[pop1] / t_sum) + (t_sum2 * data.coalescence_probability[pop2] / t_sum))\n",
    "                                #print(value_of_cur_fun, 1, i, j)\n",
    "                            elif i < k < j:\n",
    "                                #print(k, i, j)\n",
    "                                t_sum = 0\n",
    "                                t_sum1 = 0\n",
    "                                t_sum2 = 0\n",
    "                                for l in range(data.number_of_populations):\n",
    "                                    for q in range(data.number_of_populations):\n",
    "                                        t_sum += p2[l * data.number_of_populations + q,  int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + k - i - 1)]\n",
    "                                t_sum1 += p2[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + k - i - 1)]\n",
    "                                t_sum2 += p2[pop2 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-k-1)*(n-k)/2 + j - k - 1)]\n",
    "                                value_of_cur_fun -= p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * ((t_sum1 * data.coalescence_probability[pop1] / t_sum) + (t_sum2 * data.coalescence_probability[pop2] / t_sum))\n",
    "                                #print(value_of_cur_fun, 2, i, j)\n",
    "                            elif ( k > j):\n",
    "                                #print(k, i, j)\n",
    "                                t_sum = 0\n",
    "                                t_sum1 = 0\n",
    "                                t_sum2 = 0\n",
    "                                for l in range(data.number_of_populations):\n",
    "                                    for q in range(data.number_of_populations):\n",
    "                                        t_sum += p2[l * data.number_of_populations + q, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + k - i - 1)]\n",
    "                                t_sum1 += p2[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + k - i - 1)]\n",
    "                                t_sum2 += p2[pop2 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-j-1)*(n-j)/2 + k - j - 1)]\n",
    "                                value_of_cur_fun -= p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * ((t_sum1 * data.coalescence_probability[pop1] / t_sum) + (t_sum2 * data.coalescence_probability[pop2] / t_sum))\n",
    "                                #print(value_of_cur_fun, 3, i, j)\n",
    "                        ################################################\n",
    "                        ################################################\n",
    "                        if pop1 == pop2:\n",
    "                            value_of_cur_fun -= data.coalescence_probability[pop1] * p2[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)]\n",
    "                        #print(value_of_cur_fun, 4, i, j)\n",
    "\n",
    "                        result[pop1 * data.number_of_populations + pop2].append(value_of_cur_fun)\n",
    "                        value_of_cur_fun = 0\n",
    "                        #print(result)\n",
    "            \n",
    "    result = np.reshape(result, (1, -1))[0]\n",
    "\n",
    "    return result\n",
    "\n",
    "\n",
    "\n",
    "def create_initial(data: Tree,\n",
    "                   period: int,\n",
    "                   previous_states: np.ndarray = None,\n",
    "                   lineage: np.ndarray = None) -> np.ndarray:\n",
    "    \"\"\"\n",
    "    :param data:\n",
    "    :param period:\n",
    "    :param previous_states: probabilities before coalescence\n",
    "    :param lineage: contains two samples that participated in coalescence\n",
    "    :return: result: vector of initial states for current \"period\"\n",
    "    \"\"\"\n",
    "    #data.number_of_samples\n",
    "    # *** обращение к нужному p через индекс ( pop * data.cur_samples_amount + i )\n",
    "    n = data.cur_samples_amount\n",
    "    if period == 0:\n",
    "        result = [[] for i in range(data.number_of_populations ** 2)]\n",
    "        for i in range(data.number_of_populations):\n",
    "            for j in range(data.number_of_populations):\n",
    "                a1 = data.number_of_samples[i]\n",
    "                a2 = data.number_of_samples[j]\n",
    "                n1 = np.sum(data.number_of_samples[:i])\n",
    "                n2 = np.sum(data.number_of_samples[:j])\n",
    "                for k in range(data.samples_amount):\n",
    "                    for l in range(data.samples_amount):\n",
    "                        if k < l:\n",
    "                            if (n1 - 1 < k < n1 + a1) and (n2 - 1 < l < n2 + a2):\n",
    "                                result[data.number_of_populations * i + j].append(1)\n",
    "                            else:\n",
    "                                result[data.number_of_populations * i + j].append(0)\n",
    "        result = result = np.reshape(result, (1, -1))[0]\n",
    "        return(result)\n",
    "    else:\n",
    "        previous_states = np.reshape(previous_states, ( data.number_of_populations ** 2, -1))\n",
    "        lineage = np.sort(lineage)\n",
    "        result = [[] for i in range(data.number_of_populations ** 2)]\n",
    "        # cur_samples_sum = 0  ??нужно??\n",
    "\n",
    "        # посчитаю все условные вероятности для lineage[0] и всех 'pop'\n",
    "        conditional_prob = []\n",
    "        t_sum0 = 0\n",
    "        for l in range(data.number_of_populations):\n",
    "            for q in range(data.number_of_populations):\n",
    "                #print(n, lineage[0], lineage[1])\n",
    "                #print(int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1))\n",
    "                t_sum0 += previous_states[l * data.number_of_populations + q, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)]\n",
    "        for pop in range(data.number_of_populations):\n",
    "            conditional_prob.append((previous_states[pop * data.number_of_populations + pop, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)]) * data.coalescence_probability[pop])\n",
    "        sum_conditional_prob = np.sum(conditional_prob)  # ??? нужно ли переводить в массив ???\n",
    "        #print(sum_conditional_prob, t_sum0)\n",
    "        # по каждой популяции\n",
    "        for pop1 in range(data.number_of_populations):\n",
    "            for pop2 in range(data.number_of_populations):\n",
    "                # по каждому образцу\n",
    "                for i in range(data.cur_samples_amount -1):\n",
    "                    for j in range(data.cur_samples_amount - 1):\n",
    "                        if i < j:\n",
    "                            t_sum1 = 0\n",
    "                            if lineage[0] < i:\n",
    "                                if lineage[1] < i:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-2)*(n-i-1)/2 + j - i - 1)] * sum_conditional_prob / t_sum0)\n",
    "                                elif lineage[1] == i:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-2)*(n-i-1)/2 + j - i - 1)] * sum_conditional_prob / t_sum0)\n",
    "                                elif i < lineage[1] < j:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i)] * sum_conditional_prob / t_sum0)\n",
    "                                elif lineage[1] == j:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i)] * sum_conditional_prob / t_sum0)\n",
    "                                elif lineage[1] > j:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * sum_conditional_prob / t_sum0)\n",
    "                            elif lineage[0] == i:\n",
    "                                if lineage[1] < j:\n",
    "                                    for s in range(data.number_of_populations):\n",
    "                                        t_sum1 += previous_states[s * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i)*(n-i-1)/2 + j - i)]\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(t_sum1 * previous_states[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)] * data.coalescence_probability[pop1]/ t_sum0)\n",
    "                                elif lineage[1] == j:\n",
    "                                    for s in range(data.number_of_populations):\n",
    "                                        t_sum1 += previous_states[s * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i)*(n-i-1)/2 + j - i)]\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(t_sum1 * previous_states[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)] * data.coalescence_probability[pop1]/ t_sum0)\n",
    "                                elif lineage[1] > j:\n",
    "                                    for s in range(data.number_of_populations):\n",
    "                                        t_sum1 += previous_states[s * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i)*(n-i-1)/2 + j - i - 1)]\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(t_sum1 * previous_states[pop1 * data.number_of_populations + pop1, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)]* data.coalescence_probability[pop1] / t_sum0)\n",
    "                            elif i < lineage[0] < j:\n",
    "                                if lineage[1] <= j:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i)] * sum_conditional_prob / t_sum0)\n",
    "                                elif lineage[1] > j:\n",
    "                                    result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * sum_conditional_prob / t_sum0)\n",
    "                            elif lineage[0] == j:\n",
    "                                for s in range(data.number_of_populations):\n",
    "                                    t_sum1 += previous_states[pop1 * data.number_of_populations + s, int(n*(n-1)/2 - (n-i)*(n-i-1)/2 + j - i - 1)]\n",
    "                                result[pop1 * data.number_of_populations + pop2].append(t_sum1 * previous_states[pop2 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-lineage[0]-1)*(n-lineage[0])/2 + lineage[1] - lineage[0] - 1)] / t_sum0 * data.coalescence_probability[pop2])\n",
    "                            elif lineage[0] > j:\n",
    "                                result[pop1 * data.number_of_populations + pop2].append(previous_states[pop1 * data.number_of_populations + pop2, int(n*(n-1)/2 - (n-i-1)*(n-i)/2 + j - i - 1)] * sum_conditional_prob / t_sum0)\n",
    "        result = np.reshape(result, (1, -1))[0]\n",
    "        result2 = np.reshape(result, (data.number_of_populations ** 2, -1))\n",
    "        data.cur_samples_amount += -1\n",
    "        return result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prop_1(limits_list: np.array, lineage_list :np.array, tree: Tree):\n",
    "    previous_states = None\n",
    "    sol_lines_list = []\n",
    "    sol_init_states = []\n",
    "    for period in range(tree.samples_amount - 1):\n",
    "        #########################################\n",
    "        #                 ЛИНИИ                 #\n",
    "        #########################################\n",
    "        # тут находятся индексы образцов, принимающих участие в коалесценции в каждом периоде\n",
    "        # при этом после кажой коалесценции инлексы после j-ого уменьшаются на один\n",
    "        #print(tree.cur_samples_amount)\n",
    "        lineage = lineage_list[period]\n",
    "        limits = limits_list[period]  # ...\n",
    "        # последний столбец решений\n",
    "        if period != 0:\n",
    "            previous_states = np.array(sol_lines_list[-1])[:, -1]\n",
    "        initial_states = create_initial0(tree, period, previous_states=previous_states, lineage=lineage)\n",
    "        #print(initial_states)\n",
    "        # ...\n",
    "        # нужно ли находить значения функции только в точках с целым dt или в этом необходимости нет?\n",
    "        t_span = np.linspace(limits[0], limits[1], 10001)\n",
    "        # решение диффуров для вероятностей линий на данном периоде\n",
    "        q = np.array(solve_ivp(lambda t, y: system_of_DE_for_lines(tree, y),\n",
    "                                    t_span=limits,\n",
    "                                    y0=initial_states,\n",
    "                                    t_eval=t_span).y)\n",
    "        q[q < 0] = np.exp(-15)\n",
    "        sol_lines_list.append(q)\n",
    "        \n",
    "        tree.cur_samples_amount -= 1\n",
    "    result = np.sum(create_initial0(tree, period = 1, previous_states=np.array(sol_lines_list[-1])[:, -1], lineage=np.array([0, 1])))\n",
    "    #print(np.array(sol_lines_list)) \n",
    "    return result\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prop_2(limits_list: np.array, lineage_list :np.array, tree: Tree):\n",
    "    previous_states = None\n",
    "    sol_lines_list = []\n",
    "    sol_init_states = []\n",
    "    for period in range(tree.samples_amount - 1):\n",
    "        #########################################\n",
    "        #                 ЛИНИИ                 #\n",
    "        #########################################\n",
    "        # тут находятся индексы образцов, принимающих участие в коалесценции в каждом периоде\n",
    "        # при этом после кажой коалесценции инлексы после j-ого уменьшаются на один\n",
    "        #print(tree.cur_samples_amount)\n",
    "        lineage = lineage_list[period]\n",
    "        limits = limits_list[period]  # ...\n",
    "        # последний столбец решений\n",
    "        if period != 0:\n",
    "            previous_states = np.array(sol_lines_list[-1])[:, -1]\n",
    "        initial_states = create_initial(tree, period, previous_states=previous_states, lineage=lineage)\n",
    "        #print(initial_states)\n",
    "        # ...\n",
    "        # нужно ли находить значения функции только в точках с целым dt или в этом необходимости нет?\n",
    "        t_span = np.linspace(limits[0], limits[1], 10001)\n",
    "        # решение диффуров для вероятностей линий на данном периоде\n",
    "        q = np.array(solve_ivp(lambda t, y: system_of_DE_for_lines_2(tree, y),\n",
    "                                        t_span=limits,\n",
    "                                        y0=initial_states,\n",
    "                                        t_eval=t_span).y)\n",
    "        q[q < 0] = np.exp(-15)\n",
    "        sol_lines_list.append(q)\n",
    "    \n",
    "\n",
    "    #print(np.array(sol_lines_list)) \n",
    "    result = 0\n",
    "    for i in range(tree.number_of_populations):\n",
    "        result += np.array(sol_lines_list[-1])[:, -1][i * tree.number_of_populations + i] * tree.coalescence_probability[i]\n",
    "    return result\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "def msprime_to_masco(tree):\n",
    "    t = []\n",
    "    a = str(tree)\n",
    "    b = a.replace(\":\", \"\").replace(\"{\", \"\").replace(\"}\", \"\").replace(\" \", \"\").split(\",\")\n",
    "    d = []\n",
    "    for i in range(len(b)):\n",
    "        d.append(int(b[i][len(str(i)):]))\n",
    "    a = np.array(d)\n",
    "    n = int(len(a)/2 + 1) \n",
    "    m = copy.deepcopy(n)\n",
    "    z = []\n",
    "    for i in range(n-1):\n",
    "        p, q = np.where(a == m)[0][0], np.where(a == m)[0][1]\n",
    "        a = a - 2\n",
    "        b = np.zeros(len(a) - 2)\n",
    "        for j in range(len(a) - 2):\n",
    "            if j < q and j !=p:\n",
    "                b[j] = a[j]\n",
    "            elif j == p:\n",
    "                b[j] = a[m]\n",
    "            elif q <= j < m - 1:\n",
    "                b[j] = a[j + 1]\n",
    "            elif m - 1 <= j:\n",
    "                b[j] = a[j+2]\n",
    "        m -= 1\n",
    "        a = np.copy(b)\n",
    "        z.append([p, q])\n",
    "        t.append([tree.get_time(i + n-1), tree.get_time(i + n)])\n",
    "    return [z, t]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{0: 9, 1: 8, 2: 6, 3: 6, 4: 7, 5: 7, 6: 8, 7: 10, 8: 9, 9: 10}\n",
      "[[[2, 3], [3, 4], [1, 2], [0, 1], [0, 1]], [[0.0, 3561.5215564590603], [3561.5215564590603, 8220.39777465245], [8220.39777465245, 12588.107426027733], [12588.107426027733, 16755.29352939858], [16755.29352939858, 37339.64420423456]]]\n"
     ]
    },
    {
     "data": {
      "image/svg+xml": [
       "<svg baseProfile=\"full\" height=\"200\" version=\"1.1\" width=\"200\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:ev=\"http://www.w3.org/2001/xml-events\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><defs><style type=\"text/css\"><![CDATA[.axis {font-weight: bold}.tree, .axis {font-size: 14px; text-anchor:middle}.edge {stroke: black; fill: none}.node > .sym {fill: black; stroke: none}.tree text {dominant-baseline: middle}.tree .lab.lft {text-anchor: end}.tree .lab.rgt {text-anchor: start}.mut {fill: red; font-style: italic}]]></style></defs><g class=\"tree t0\"><g class=\"node n10 p1 root\" transform=\"translate(104.821 30.0)\"><g class=\"a10 node n7 p1\" transform=\"translate(46.6071 109.179)\"><g class=\"a7 leaf node n4 p1 sample\" transform=\"translate(-12.8571 30.8213)\"><path class=\"edge\" d=\"M 0 0 V -30.8213 H 12.8571\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab\" transform=\"translate(0 12)\">4</text></g><g class=\"a7 leaf node n5 p2 sample\" transform=\"translate(12.8571 30.8213)\"><path class=\"edge\" d=\"M 0 0 V -30.8213 H -12.8571\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:green;\"/><text class=\"lab\" transform=\"translate(0 12)\">5</text></g><path class=\"edge\" d=\"M 0 0 V -109.179 H -46.6071\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab rgt\" transform=\"translate(3 -6)\">7</text></g><g class=\"a10 node n9 p1\" transform=\"translate(-46.6071 77.1783)\"><g class=\"a9 leaf node n0 p0 sample\" transform=\"translate(-22.5 62.8217)\"><path class=\"edge\" d=\"M 0 0 V -62.8217 H 22.5\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:red;\"/><text class=\"lab\" transform=\"translate(0 12)\">0</text></g><g class=\"a9 node n8 p1\" transform=\"translate(22.5 15.6243)\"><g class=\"a8 leaf node n1 p0 sample\" transform=\"translate(-19.2857 47.1974)\"><path class=\"edge\" d=\"M 0 0 V -47.1974 H 19.2857\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:red;\"/><text class=\"lab\" transform=\"translate(0 12)\">1</text></g><g class=\"a8 node n6 p1\" transform=\"translate(19.2857 33.844)\"><g class=\"a6 leaf node n2 p0 sample\" transform=\"translate(-12.8571 13.3534)\"><path class=\"edge\" d=\"M 0 0 V -13.3534 H 12.8571\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:red;\"/><text class=\"lab\" transform=\"translate(0 12)\">2</text></g><g class=\"a6 leaf node n3 p1 sample\" transform=\"translate(12.8571 13.3534)\"><path class=\"edge\" d=\"M 0 0 V -13.3534 H -12.8571\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab\" transform=\"translate(0 12)\">3</text></g><path class=\"edge\" d=\"M 0 0 V -33.844 H -19.2857\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab rgt\" transform=\"translate(3 -6)\">6</text></g><path class=\"edge\" d=\"M 0 0 V -15.6243 H -22.5\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab rgt\" transform=\"translate(3 -6)\">8</text></g><path class=\"edge\" d=\"M 0 0 V -77.1783 H 46.6071\"/><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab lft\" transform=\"translate(-3 -6)\">9</text></g><circle class=\"sym\" cx=\"0\" cy=\"0\" r=\"3\" style=\"fill:blue;\"/><text class=\"lab\" transform=\"translate(0 -10)\">10</text></g></g></svg>"
      ],
      "text/plain": [
       "<IPython.core.display.SVG object>"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pop_configs = [msprime.PopulationConfiguration(sample_size=3, initial_size=10000),\n",
    "               msprime.PopulationConfiguration(sample_size=2, initial_size=10000),\n",
    "               msprime.PopulationConfiguration(sample_size=1, initial_size=10000)]\n",
    "migration_matrix = [[0, 0.1, 0.5],\n",
    "                    [0.1, 0, 1],\n",
    "                    [0.01, 2, 0]]\n",
    "ts = msprime.simulate(\n",
    "population_configurations=pop_configs, migration_matrix=migration_matrix,\n",
    "record_migrations=True)\n",
    "tree = ts.first()\n",
    "colour_map = {0:\"red\", 1:\"blue\", 2:\"green\"}\n",
    "node_colours = {u: colour_map[tree.population(u)] for u in tree.nodes()}\n",
    "print(tree)\n",
    "print(msprime_to_masco(tree))\n",
    "SVG(tree.draw(node_colours=node_colours))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "def MASCO2():\n",
    "    Q1 = []\n",
    "    Q2 = []\n",
    "    for m in np.linspace(0.001, 2, 100):\n",
    "        # M is the overall symmetric migration rate, and d is the number\n",
    "        # of demes.\n",
    "        # We rescale m into per-generation values for msprime.\n",
    "        # Allocate the initial sample. Because we are interested in the\n",
    "        # between deme coalescence times, we choose one sample each\n",
    "        # from the first two demes.\n",
    "        population_configurations = [\n",
    "        msprime.PopulationConfiguration(sample_size=2, initial_size=10000),\n",
    "        msprime.PopulationConfiguration(sample_size=2, initial_size=10000)]\n",
    "            # Now we set up the migration matrix. Since this is a symmetric\n",
    "            # island model, we have the same rate of migration between all\n",
    "            # pairs of demes. Diagonal elements must be zero.\n",
    "        m1 = m/20000\n",
    "        migration_matrix1 = [[0, m1],\n",
    "                             [m1, 0]]\n",
    "        migration_matrix2 = [[0, m],\n",
    "                             [m, 0]]\n",
    "            # We pass these values to the simulate function, and ask it\n",
    "            # to run the required number of replicates.\n",
    "            #migration_matrix=migration_matrix,\n",
    "        num_replicates = 1000\n",
    "        replicates = msprime.simulate(\n",
    "            population_configurations=population_configurations,\n",
    "            migration_matrix=migration_matrix1,\n",
    "            num_replicates=num_replicates)\n",
    "            # And then iterate over these replicates\n",
    "        P1 = np.zeros(num_replicates)\n",
    "        P2 = np.zeros(num_replicates)\n",
    "        for i, tree_sequence in enumerate(replicates):\n",
    "            tree = next(tree_sequence.trees())\n",
    "            lineage_list, limits_list = msprime_to_masco(tree)[0], np.array(msprime_to_masco(tree)[1]) / 20000\n",
    "            # Convert the TMRCA to coalecent units.\n",
    "            tree_1 = Tree(migration_rates = migration_matrix2, number_of_samples = [2, 2], number_of_populations = 2, coalescence_rates = [1, 1], coalescence_time = 1000000, Q = 1, N = 1000)\n",
    "            P2[i] = prop_2(limits_list = limits_list, lineage_list = lineage_list, tree = tree_1)\n",
    "            tree_1 = Tree(migration_rates = migration_matrix2, number_of_samples = [2, 2], number_of_populations = 2, coalescence_rates = [1, 1], coalescence_time = 1000000, Q = 1, N = 1000)\n",
    "            P1[i] = prop_1(limits_list = limits_list, lineage_list = lineage_list, tree = tree_1)\n",
    "                #print(lineage_list, limits_list)\n",
    "        D1 = np.sum(np.log10(P1))\n",
    "        D2 = np.sum(np.log10(P2))\n",
    "        Q1.append(D1)\n",
    "        Q2.append(D2)\n",
    "        \n",
    "            #Res1 = (1 / num_replicates) * np.sum()\n",
    "            # Finally, calculate the analytical expectation and print\n",
    "            # out the results\n",
    "            #print(\"Observed  =\", np.mean(T))\n",
    "        print(\"Masco1 =\", D1, \"Masco2 =\", D2, \"migr =\", m)\n",
    "            #print(\"Masco2 =\", P1, P2)\n",
    "    #print(np.array(D1).shape, np.array(D2).shape, m_span.shape)\n",
    "    m_span = np.linspace(0.001, 2, 100)\n",
    "    return(Q1, Q2, m_span)\n",
    "\n",
    "    \n",
    "def graph(P1, P2, m):\n",
    "    x = np.array(P1) - np.array(P2)\n",
    "    fig, ax = plt.subplots()\n",
    "\n",
    "    ax.plot(m, x, color=\"red\")\n",
    "    ax.grid()\n",
    "\n",
    "    #ax.plot(m, P2, color=\"blue\")\n",
    "    #ax.grid()\n",
    "    \n",
    "    ax.set_xlabel(\"migration_coef\")\n",
    "    ax.set_ylabel(\"logm1 - logm2\")\n",
    "\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Masco1 = -6226.238579638074 Masco2 = -6242.978793974573 migr = 0.001\n",
      "Masco1 = -4359.131611110759 Masco2 = -4610.8005686547785 migr = 0.021191919191919192\n",
      "Masco1 = -3853.882231695162 Masco2 = -4099.482146846447 migr = 0.041383838383838384\n",
      "Masco1 = -3519.644663904992 Masco2 = -3748.2439041911302 migr = 0.061575757575757575\n",
      "Masco1 = -3322.860448489232 Masco2 = -3517.694110535623 migr = 0.08176767676767677\n",
      "Masco1 = -3203.223569575006 Masco2 = -3373.02038556434 migr = 0.10195959595959596\n",
      "Masco1 = -3116.839901350083 Masco2 = -3265.793220588099 migr = 0.12215151515151515\n",
      "Masco1 = -3062.617837621803 Masco2 = -3173.308651654762 migr = 0.14234343434343433\n",
      "Masco1 = -2947.680270967183 Masco2 = -3057.2492667377046 migr = 0.16253535353535353\n",
      "Masco1 = -2910.2041492415697 Masco2 = -2999.950992283937 migr = 0.18272727272727274\n",
      "Masco1 = -2908.3105081331023 Masco2 = -2964.78562908799 migr = 0.20291919191919192\n",
      "Masco1 = -2822.631410719007 Masco2 = -2878.2262234252753 migr = 0.2231111111111111\n",
      "Masco1 = -2817.2736529936037 Masco2 = -2853.7272109483 migr = 0.2433030303030303\n",
      "Masco1 = -2704.675005895794 Masco2 = -2744.855568790041 migr = 0.2634949494949495\n",
      "Masco1 = -2750.672819112644 Masco2 = -2758.9799987133556 migr = 0.28368686868686865\n",
      "Masco1 = -2729.826695088493 Masco2 = -2735.133887235966 migr = 0.30387878787878786\n",
      "Masco1 = -2679.9857494981006 Masco2 = -2682.686875695883 migr = 0.32407070707070706\n",
      "Masco1 = -2678.3123763112635 Masco2 = -2672.025605929493 migr = 0.34426262626262627\n",
      "Masco1 = -2669.611571141152 Masco2 = -2644.767601165625 migr = 0.3644545454545455\n",
      "Masco1 = -2572.959602798306 Masco2 = -2567.7223727023093 migr = 0.3846464646464646\n",
      "Masco1 = -2593.0140528047104 Masco2 = -2577.887092755605 migr = 0.40483838383838383\n",
      "Masco1 = -2585.2332195262984 Masco2 = -2557.106628709094 migr = 0.42503030303030304\n",
      "Masco1 = -2617.033984107986 Masco2 = -2566.864258428957 migr = 0.4452222222222222\n",
      "Masco1 = -2585.600180459146 Masco2 = -2538.8580044709984 migr = 0.4654141414141414\n",
      "Masco1 = -2573.1393380894306 Masco2 = -2518.192105760332 migr = 0.4856060606060606\n",
      "Masco1 = -2525.335106168518 Masco2 = -2471.868165836565 migr = 0.5057979797979798\n",
      "Masco1 = -2558.583329463344 Masco2 = -2489.4344586485413 migr = 0.525989898989899\n",
      "Masco1 = -2486.987664415171 Masco2 = -2430.4593589626234 migr = 0.5461818181818182\n",
      "Masco1 = -2526.5481399814234 Masco2 = -2448.0713589258394 migr = 0.5663737373737373\n",
      "Masco1 = -2500.887317068138 Masco2 = -2423.4683229562565 migr = 0.5865656565656565\n",
      "Masco1 = -2485.1083360898956 Masco2 = -2402.5862621750175 migr = 0.6067575757575757\n",
      "Masco1 = -2462.256924211096 Masco2 = -2381.2175876308947 migr = 0.6269494949494949\n",
      "Masco1 = -2504.546491472916 Masco2 = -2404.019944311345 migr = 0.6471414141414141\n",
      "Masco1 = -2466.320767597902 Masco2 = -2373.9572130073057 migr = 0.6673333333333333\n",
      "Masco1 = -2470.6097282321816 Masco2 = -2370.9507447296205 migr = 0.6875252525252525\n",
      "Masco1 = -2458.8628723392176 Masco2 = -2352.8265830117043 migr = 0.7077171717171717\n",
      "Masco1 = -2458.4803860383586 Masco2 = -2351.7872445767307 migr = 0.727909090909091\n",
      "Masco1 = -2432.362800100941 Masco2 = -2327.583869597609 migr = 0.74810101010101\n",
      "Masco1 = -2454.0944200823214 Masco2 = -2347.1267134761115 migr = 0.7682929292929292\n",
      "Masco1 = -2468.5986946001854 Masco2 = -2343.5755386190112 migr = 0.7884848484848485\n",
      "Masco1 = -2429.7964883977074 Masco2 = -2319.5303601632736 migr = 0.8086767676767677\n",
      "Masco1 = -2433.4487455731287 Masco2 = -2313.1775701982046 migr = 0.8288686868686869\n",
      "Masco1 = -2421.33715226967 Masco2 = -2297.921255076102 migr = 0.8490606060606061\n",
      "Masco1 = -2411.2923481410617 Masco2 = -2281.1573359042945 migr = 0.8692525252525253\n",
      "Masco1 = -2404.403342580629 Masco2 = -2272.0043644397438 migr = 0.8894444444444444\n",
      "Masco1 = -2390.5965446232153 Masco2 = -2267.8417497999653 migr = 0.9096363636363636\n",
      "Masco1 = -2439.2088155148226 Masco2 = -2296.873422155827 migr = 0.9298282828282828\n",
      "Masco1 = -2379.9104460113026 Masco2 = -2248.741670292911 migr = 0.950020202020202\n",
      "Masco1 = -2423.7282814450436 Masco2 = -2272.6287385995483 migr = 0.9702121212121212\n",
      "Masco1 = -2436.1056336796223 Masco2 = -2283.3101098651036 migr = 0.9904040404040404\n",
      "Masco1 = -2377.4298102171824 Masco2 = -2236.265913543673 migr = 1.0105959595959595\n",
      "Masco1 = -2399.0515511789536 Masco2 = -2250.4513849700443 migr = 1.0307878787878786\n",
      "Masco1 = -2408.102414228103 Masco2 = -2251.6354908356752 migr = 1.050979797979798\n",
      "Masco1 = -2397.005471074433 Masco2 = -2248.368165997749 migr = 1.071171717171717\n",
      "Masco1 = -2401.380188362944 Masco2 = -2244.8016676424736 migr = 1.0913636363636363\n",
      "Masco1 = -2451.8234609427022 Masco2 = -2283.973087016987 migr = 1.1115555555555554\n",
      "Masco1 = -2315.4579272971337 Masco2 = -2170.0398685632726 migr = 1.1317474747474745\n",
      "Masco1 = -2400.257179674461 Masco2 = -2229.413251822629 migr = 1.1519393939393938\n",
      "Masco1 = -2415.2253026248613 Masco2 = -2237.417929703274 migr = 1.172131313131313\n",
      "Masco1 = -2341.968050717129 Masco2 = -2185.3662483616586 migr = 1.1923232323232322\n",
      "Masco1 = -2401.525810199227 Masco2 = -2225.3269097825446 migr = 1.2125151515151513\n",
      "Masco1 = -2396.85977216956 Masco2 = -2224.1486302234066 migr = 1.2327070707070706\n",
      "Masco1 = -2383.8636286521146 Masco2 = -2205.372971736803 migr = 1.2528989898989897\n",
      "Masco1 = -2353.508095021335 Masco2 = -2181.4610296953783 migr = 1.273090909090909\n",
      "Masco1 = -2369.1871948479197 Masco2 = -2200.761661265601 migr = 1.2932828282828281\n",
      "Masco1 = -2344.7136053710087 Masco2 = -2175.5293801390926 migr = 1.3134747474747472\n",
      "Masco1 = -2360.9469365237173 Masco2 = -2188.2903142302066 migr = 1.3336666666666666\n",
      "Masco1 = -2339.6452902968585 Masco2 = -2169.6916613665157 migr = 1.3538585858585857\n",
      "Masco1 = -2307.3074666510956 Masco2 = -2145.517336310071 migr = 1.374050505050505\n",
      "Masco1 = -2334.6607693999663 Masco2 = -2153.209023128933 migr = 1.394242424242424\n",
      "Masco1 = -2319.5772764187286 Masco2 = -2148.9823881474003 migr = 1.4144343434343434\n",
      "Masco1 = -2337.0581607894574 Masco2 = -2157.4425583881493 migr = 1.4346262626262625\n",
      "Masco1 = -2372.7625958608287 Masco2 = -2176.4652272470753 migr = 1.4548181818181818\n",
      "Masco1 = -2374.9627786406054 Masco2 = -2187.125588121047 migr = 1.4750101010101009\n",
      "Masco1 = -2346.132598646354 Masco2 = -2155.971647915148 migr = 1.49520202020202\n",
      "Masco1 = -2362.911761598338 Masco2 = -2177.776748306225 migr = 1.5153939393939393\n",
      "Masco1 = -2363.456529059344 Masco2 = -2170.907469942992 migr = 1.5355858585858584\n",
      "Masco1 = -2356.0289857856233 Masco2 = -2172.091618238473 migr = 1.5557777777777777\n",
      "Masco1 = -2332.231351050029 Masco2 = -2140.416433323916 migr = 1.5759696969696968\n",
      "Masco1 = -2326.978455432056 Masco2 = -2130.4297231268074 migr = 1.5961616161616161\n",
      "Masco1 = -2341.9593194781683 Masco2 = -2155.4422161327657 migr = 1.6163535353535352\n",
      "Masco1 = -2323.42040078847 Masco2 = -2131.834964514882 migr = 1.6365454545454543\n",
      "Masco1 = -2346.504056394707 Masco2 = -2144.4266889698147 migr = 1.6567373737373736\n",
      "Masco1 = -2299.313298725882 Masco2 = -2116.184320889627 migr = 1.6769292929292927\n",
      "Masco1 = -2328.087930079654 Masco2 = -2127.6289504896386 migr = 1.697121212121212\n",
      "Masco1 = -2351.1843964897525 Masco2 = -2146.3266970748327 migr = 1.7173131313131311\n",
      "Masco1 = -2304.1849259628852 Masco2 = -2113.621153720955 migr = 1.7375050505050504\n",
      "Masco1 = -2337.6598820754325 Masco2 = -2143.879201060875 migr = 1.7576969696969695\n",
      "Masco1 = -2337.7633820044784 Masco2 = -2133.7012212601103 migr = 1.7778888888888886\n",
      "Masco1 = -2357.2861790159304 Masco2 = -2149.1582063799533 migr = 1.798080808080808\n",
      "Masco1 = -2319.868445505511 Masco2 = -2126.2630902442825 migr = 1.818272727272727\n",
      "Masco1 = -2341.418966318617 Masco2 = -2138.5962479409845 migr = 1.8384646464646464\n",
      "Masco1 = -2300.553494348448 Masco2 = -2102.3660593600816 migr = 1.8586565656565655\n",
      "Masco1 = -2342.403740028055 Masco2 = -2132.3970138224304 migr = 1.8788484848484848\n",
      "Masco1 = -2318.290689050127 Masco2 = -2114.383510813232 migr = 1.8990404040404039\n",
      "Masco1 = -2312.3736201610986 Masco2 = -2102.5818812696552 migr = 1.9192323232323232\n",
      "Masco1 = -2309.808581916931 Masco2 = -2105.86534697539 migr = 1.9394242424242423\n",
      "Masco1 = -2321.712667012818 Masco2 = -2112.5988385413325 migr = 1.9596161616161614\n",
      "Masco1 = -2271.979133776691 Masco2 = -2068.881529295698 migr = 1.9798080808080807\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Masco1 = -2306.2374880542293 Masco2 = -2094.7638697496755 migr = 2.0\n"
     ]
    },
    {
     "data": {
      "image/png": "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R3HVTipxrVjhXlrqvs467h9+WOkhtY5r8mT33r3dwf3ss1fdv3Che69e7uuv7/7mm+4tWrhfcEH5/qOOcl99dfeysvKyb7+NskGD/lv0yqhRUdavn/vSpau+z5dfunfo4N6mjXvr1u4TJ5bvKytzf/RR9yVLavez5aA+/47AFK/i92oqNQ13/5e7Z4YmTAS6Jc8HAaPcfbG7fwjMBvok22x3n+PuS4BRybEi0hSYxV/8b70FG2+cn2vusANMnRrNThX7OADatYuhtV98EX0cK1bE6KyM00+Ppqi77iovu/baKMusqAgsLimJCSRffTWGFVf0l7/E2u7jxkHXrnGz45dfwrPPxnxghx7aqKaQN0/5phoz+z/gQXe/z8xuBCa6+33JvjuAzOIAA9z95KR8KNDX3c+s5HrDgeEAJSUlpaNGjapzbGVlZXTs2LHO5xeK4qodxVU7zS2uje65h+4jR/LdVlsx7brryne4s90ZZ/CTWbP49IAD+GTIEEp//nO+3W473rrsslXi2uLyy1n7hRd448Yb+b5nTwBazZ/PjkOG8HW/fsy6+GI6vv8+2555JktXX512X37Jj926sbhLF37y9tu8NnIki9Zfv84/R7tPP2VFmzYs6dJlpbjqYo899pjq7ttXurOqKkh9N+BZYGYl26CsYy4EHqU8ed0EHJu1/w5gMHA4cHtW+VDghppiUPNUcSmu2lFctVOwuJYudT/1VPfnnlt134IF7iNGuLdsGc1X4D59euVxffONe7du7htu6P7kk9HkdsEF7mbub71VfsLdd7u3a+d+/vnuP/7oPneue8eO7vvvH+e4u48f777JJu6XXuq+fHn5uW+95b7NNu7HH+8+f355+YMPxjXXW8/9449XjqsOqKZ5qmCjp9x97+r2m9lxwIHAXkmQAHOB7IlsugGfJs+rKhcRqbtWrcpHUFXUqVOMwDruuOh033zzqkdJrbFGjPQ69lg48MCYZXjiRDj88OjQzxg2LNZByUzw2LVrzB48YkTMF/bttzGCrGPHaAabPj2a0Z57Lq7dpk107E+YAH//ezTrXXppDA6YNSveOzOrcAGkNXpqAHAecLC7/5i16wngKDNra2bdgR7AZOA1oIeZdTezNsBRybEiIoX305/GaK0bb6z+uD59YObM6PuYMgXKyuJ+jooqzgh89tmRjIYOjeG8u+0W09H/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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "Q1, Q2, m = MASCO2()\n",
    "\n",
    "graph(Q1, Q2, m)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
